#!/usr/bin/env python

from poster import encode, streaminghttp 
import urllib, urllib2, json, sys, time

def scan_file(filepath, vtconfigfile, timeinterval=15, verbose=False):
  """
  Upload a file to VirusTotal for virus scanning.

  Parameters:
    filepath - The path of the file to upload
    vtconfigfile - The file containing the information for VirusTotal
    timeinterval - the time interval for retrying
  
  Returns:
    The dictionary that contains the reponse of VirusTotal

  """
  
  # Configuration file of VirusTotal
  vtconfig = json.load(open(vtconfigfile, 'r'))

  # Register the streaming http handlers with urllib2.
  streaminghttp.register_openers()

  # headers: the necessary Content-Type and Content-Length
  # datagen: a generator object that yields the encoded parameters
  datagen, headers = encode.multipart_encode({
    'apikey': vtconfig['apikey'],
    'file': open(filepath, 'rb'),
  })

  # Create the request object.
  request = urllib2.Request(vtconfig['scan_url'], datagen, headers)

  # Do the request and get the response. If the response is invalid
  # (204), do the request again after the specific time interval.
  while True:
    response = urllib2.urlopen(request)

    # Check if the request rate limit is exceeded.
    if response.getcode() == 204:
      if verbose:
        sys.stdout.write('.')
        sys.stdout.flush()

      time.sleep(timeinterval)

    else:
      break

  return json.loads(response.read())


def retrieve_report(resource, vtconfigfile, timeinterval=15, verbose=False):
  """
  Retrieve the report from VirusTotal.

  Parameters:
    resource - a hash of the most recent report on a given sample
    vtconfigfile - the file containing the information for VirusTotal
    timeinterval - the time interval for retrying

  """
  
  # Configuration file of VirusTotal
  vtconfig = json.load(open(vtconfigfile, 'r'))

  # Create the request object.
  request = urllib2.Request(
      vtconfig['report_url'],
      urllib.urlencode({
        'apikey': vtconfig['apikey'],
        'resource': resource,
      })
  )

  # Do the request and get the response. If the response is invalid
  # (204), do the request again after the specific time interval.
  while True:
    response = urllib2.urlopen(request)

    # Check if the request rate limit is exceeded.
    if response.getcode() == 204:
      if verbose:
        sys.stdout.write('.')
        sys.stdout.flush()

      time.sleep(timeinterval)

    else:
      break

  return json.loads(response.read())


def main():
  pass


if __name__ == '__main__':
  main()


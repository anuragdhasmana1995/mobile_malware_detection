#!/usr/bin/env python

import feature
import psycopg2, argparse, getpass, json, sys, zipfile, struct

def main():
  #----------------------------------------------------------------------
  # Arguments
  #----------------------------------------------------------------------

  parser = argparse.ArgumentParser(description='Extract permissions from \
      apps and store them to the database', add_help=False)
  parser.add_argument('--help', action='help', help='show this help \
      message.')
  parser.add_argument('-h', metavar='host', type=str, required=True)
  parser.add_argument('-d', metavar='database', type=str, required=True)
  parser.add_argument('-u', metavar='username', type=str, required=True)
  args = parser.parse_args()

  passwd = getpass.getpass()

  #----------------------------------------------------------------------
  # Database
  #----------------------------------------------------------------------
  try:
    sql = 'host=%s dbname=%s user=%s password=%s' % \
        (args.h, args.d, args.u, passwd)
    conn = psycopg2.connect(sql)
    cur =  conn.cursor()

    # Get all the apps whose permissions have not been extracted yet.
    sql = 'SELECT a_id, a_name, a_path FROM apps WHERE a_perms IS NULL'
    cur.execute(sql)
    apps = cur.fetchall()

    # For progress bar
    total, count = len(apps), .0

    for a_id, a_name, a_path in apps:
      count += 1

      # Progress bar
      sys.stdout.write('\r')
      for i in range(80):
        sys.stdout.write(' ')
      sys.stdout.write('\r[%d%%] Extract %s ' \
          % (count * 100 / total, a_name))
      sys.stdout.flush()

      try:
        # Get the permissions
        perms = feature.get_permissions(a_path)

        sql = 'UPDATE apps SET a_perms = %s WHERE a_id = %s'
        cur.execute(sql, (perms, a_id))
        conn.commit()

      except zipfile.BadZipfile as e:
        print '\r[BadZipfile]', a_name

      except UnicodeEncodeError as e:
        print '\r[UnicodeEncodeError]', a_name

      except struct.error as e:
        print '\r[struct.error]', a_name

  except Exception as e:
    print e

  finally:
    cur.close()
    conn.close()
  

if __name__ == '__main__':
  main()

